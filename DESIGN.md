My first step in implementing this project was to create a manifest.json file that gave a brief description of the project and enabled me to override Chrome's default "new tab" page to instead display my index.html file. In this manifest.json file, I also obtained permission to access Chrome's storage functionality and geolocation functionality (both of which will be important later on). Finally, I identified the content script associated with this project (content.js).

In my content script, the first thing I wanted to do was to change the background to load a random image every time, which I achieved with my loadBackground() function. This function made use of functions in the Math library to obtain a random number, after which I created a URL link to the images in my image/ folder. 

Next, I wanted to enable the user to set their username and for the extension to remember this username in order to greet the user each time. I did this by creating a button in my index.html file ("Edit Name"), and adding an event listener for the button being clicked to run my editName() function. This function created a prompt for the user to enter their username, which I then saved as a key:value pair in Chrome's storage using the chrome.storage.sync.set() function. Then, when I wanted to load the username with the loadUsername() function, I used the chrome.storage.sync.get() function to access it. 

Then, I wanted to be able to display the time and date. I made use of built-in Javascript functions to get the relevant hour, minute, date, and month based on the user's location. I displayed the hour and minutes as a digital clock in the center of the window. Then, based on the hour and the username, I customized a greeting (for example, "Good afternoon, user" if the hour were between 12 and 18) to greet the user.

Next, I wanted to be able to link to the HUDS menu. This was pretty straightforward to accomplish - I just added a button in the top right corner of the window, added an event listener to listen for the button being clicked, and then linked to the relevant HUDS menu (the lunch menu if it were before 2pm, and the dinner menu if it were after). My initial intention had been to query the HUDS API in order to display the menu itself within the extension, but after I found out that the HUDS API had been discontinued, I realized that I would have to use a web scraper instead which might be too difficult. Thus, I decided just to link to it.

After that, I wanted to add sticky note functionality. I borrowed some CSS to style the sticky note (with a gradient) and displayed it in the top left corner of the screen. I overlayed an editable text box on top of the sticky note for the user to edit, with any overflow text triggering a scrollbar so that text did not spill out of the sticky note. Since the sticky note is quite prominent, I wanted to enable the user to be able to hide it in case it proved to clutter the screen. I achieved this by making use of Chrome's storage functions again to save whenever the user clicked the "X" to hide the sticky note, and to save whenever the user clicked the "Notes" button to show the sticky note. Then, the next time the user opened a new tab, the sticky note would be shown or hidden based on the status saved in Chrome's storage. 

My final step proved to be the most difficult one. I wanted to be able to get weather data based on the user's location and display it on the screen. To do this, I first had to use my getLocation() function to obtain the user's geographic coordinates. Then, I had to pass these coordinates to my showCoordinates()  function and include them in my API query to the OpenWeatherMap API through a XMLHttpRequest. I had to parse this response text into a Javascript object. Then, I had to change the elements on my screen to reflect this new data, including changing the weather icon. I also wanted to enable the user to choose whether they wanted the weather information displayed in Celsius or Fahrenheit. In order to do this, I created a toggle that, when clicked, used Chrome's storage function to save the user's preferences. Then, I included this choice in the API query (for example, "&units=metric" if the user preferred Celsius).